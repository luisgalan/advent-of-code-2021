/*
    ░░▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒▒▒██▓▓▒▒▒▒████▓▓▒▒▒▒▒▒░░
    ██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒
  ▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒Hele▒Danmarks▒pilsner▒▒▒▒▒▒▒░░░░▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒Ø▒▒▒N▒▒▒▒▒T▒▒U▒▒B▒▒O▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒R▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒R▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒G▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒G▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓██████▒██▒▒▒██▒█████▒▒▒█████▒▒█████▒▒▒█████▒▒▒
██▓▓▒▒██▒▒▒██▒▒▒██▒██▒▒██▒██▒▒▒██▒██▒▒██▒██▒▒▒▒▒▒▒
██▓▓▒▒██▒▒▒██▒▒▒██▒█████▒▒██▒▒▒██▒█████▒▒██▒▒███▒▒
██▓▓▒▒██▒▒▒██▒▒▒██▒██▒▒██▒██▒▒▒██▒██▒▒██▒██▒▒▒██▒▒
██▓▓▒▒██▒▒▒▒█████▒▒█████▒▒▒█████▒▒██▒▒██▒▒█████▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒*▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒*▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒P▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒L▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒I▒▒L▒▒S▒▒N▒▒E▒▒R▒▒▒▒▒▒Ø▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
████▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
████▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██████▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██████████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
  ██████████████████████████████████████████████
      ██████████████████████████████████████
*/

#include<bits/stdc++.h>
using namespace std;
void solve();
template<class F,class S>ostream&operator<<(ostream&o,const pair<F,S>p){return o<<'('<<p.first<<", "<<p.second<<')';}template<class...V>ostream&operator<<(ostream&o,const tuple<V...>t){o<<'(';apply([&o](auto&&...v){((o<<v<<", "),...);},t);o<<"\b\b)";return o;}template<class C,class T=decay<decltype(*begin(declval<C>()))>,typename enable_if<!is_same<C,string>::value>::type* =nullptr>ostream&operator<<(ostream&o,const C&v){o<<'[';for(auto&x:v)o<<x<<", ";if(!v.empty())o<<"\b\b";return o<<']';}
#define debug(x) cerr << #x << " = " << (x) << endl
#define MT(args...) make_tuple(args)
#define PB(a) push_back(a)
#define MP(a, b) make_pair(a, b)
#define FOR(i, n) for(int i = 0; i < (ll)(n); i++)
#define FORS(i,n) for(int i=1;i<=(n);i++)
#define FORE(x,a) for(auto &x: a)
#define FORT(i,a,b) for(int i=(a);i<(b);i++)
#define FORD(i,a,b) for(int i=(a);i>=(b);i--)
#define ALL(x) x.begin(),x.end()
#define F first
#define S second
#define VEC(x,y) typedef vector<x> v##y;typedef vector<v##y> vv##y;typedef vector<vv##y> vvv##y;
#define DEF(x,y) typedef x y;typedef vector<x> v##y;typedef vector<v##y> vv##y;typedef vector<vv##y> vvv##y;
#define COMMA ,
VEC(int,i)VEC(char,c)VEC(string,s)DEF(long long,ll)DEF(long double,ld)DEF(complex<ld>,com)DEF(pair<int COMMA int>,ii)DEF(tuple<int COMMA int COMMA int>,iii)
// #define endl '\n'

const int DX[4] = { 0,  1,  0, -1 };
const int DY[4] = { 1,  0, -1,  0 };
const ll INF = LLONG_MAX / 2 + INT_MAX / 2;

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cout << fixed << setprecision(10);

    int num_cases = 1;
    // cin >> num_cases;
    while (num_cases--) solve();
}

struct node {
    int value;
    int left;
    int right;
    int parent;
    node(int value, int left, int right, int parent) : value(value), left(left), right(right), parent(parent) {}

    friend ostream &operator<<(ostream &o, const node &a) {
        return o <<
            "{ v: " << a.value <<
            ", l:" << a.left <<
            ", r:" << a.right <<
            ", p:" << a.parent <<
            " }";
    }
};

using sfn = vector<node>;

// root node is at idx 1
int parse(sfn &s) {
    char c;
    cin >> c;
    if (c == '[') {
        int idx = s.size();
        s.PB(node(0,0,0,0));

        int left = parse(s);
        cin.ignore(); // ,
        int right = parse(s);
        cin.ignore(); // ]

        s[left].parent = idx;
        s[right].parent = idx;
        s[idx] = node(0, left, right, 0);
        return idx;
    } else {
        int idx = s.size();
        s.PB(node(c - '0', 0, 0, 0));
        return idx;
    }
}

sfn parse() {
    sfn res;
    res.PB(node(0, 0, 0, 0));
    parse(res);
    return res;
}

void print_sfn(sfn &s, int idx=1) {
    if (s[idx].left) {
        cout << '[';
        print_sfn(s, s[idx].left);
        cout << ',';
        print_sfn(s, s[idx].right);
        cout << ']';
    } else {
        cout << s[idx].value;
    }
}

void explode(sfn &s, int idx) {
    assert(s[idx].left);
    assert(s[idx].right);

    int v_left = s[s[idx].left].value;
    int v_right = s[s[idx].right].value;
    s[idx].left = 0;
    s[idx].right = 0;
    s[idx].value = 0;

    // find left neighbor
    int nl = s[idx].parent;
    int prev = idx;
    while (nl && s[nl].left == prev) {
        prev = nl;
        nl = s[nl].parent;
    }
    if (nl) {
        nl = s[nl].left;
        while (s[nl].right) {
            nl = s[nl].right;
        }
        s[nl].value += v_left;
    }

    // find right neighbor
    int nr = s[idx].parent;
    prev = idx;
    while (nr && s[nr].right == prev) {
        prev = nr;
        nr = s[nr].parent;
    }
    if (nr) {
        nr = s[nr].right;
        while (s[nr].left) {
            nr = s[nr].left;
        }
        s[nr].value += v_right;
    }
}

void split(sfn &s, int idx) {
    assert(!s[idx].left);
    assert(!s[idx].right);

    // node &p = s[idx]; // PLEAse never do this again this was a pain to debug
    // the vector gets reallocated so this points to the old vector (but only like 1% of the time)

    int val_l = s[idx].value / 2;
    int val_r = s[idx].value - val_l;
    s[idx].value = 0;

    int idx_l = s.size();
    s.PB(node(val_l, 0, 0, idx));

    int idx_r = s.size();
    s.PB(node(val_r, 0, 0, idx));

    s[idx].left = idx_l;
    s[idx].right = idx_r;
}

bool explode_leftmost(sfn &s, int idx, int depth) {
    assert((s[idx].left == 0) == (s[idx].right == 0));
    if (s[idx].left) assert(depth < 5);
    if (s[idx].left) assert(s[idx].value == 0);

    if (
        depth == 4 &&
        s[idx].left
    ) {
        explode(s, idx);
        return true;
    }

    return s[idx].left && (
        explode_leftmost(s, s[idx].left, depth + 1) ||
        explode_leftmost(s, s[idx].right, depth + 1)
    );
}

bool split_leftmost(sfn &s, int idx, int depth) {
    assert((s[idx].left == 0) == (s[idx].right == 0));
    if (!s[idx].left && s[idx].value >= 10) {
        split(s, idx);
        return true;
    }
    return s[idx].left && (
        split_leftmost(s, s[idx].left, depth + 1) ||
        split_leftmost(s, s[idx].right, depth + 1)
    );
}

void reduce(sfn &s) {
    while(explode_leftmost(s, 1, 0) || split_leftmost(s, 1, 0));
}

int add_sfn(sfn &a, const sfn &b, int idx) {
    if (b[idx].left) {
        assert(b[idx].right);

        int i = a.size();
        a.PB(node(0, 0, 0, 0));

        int left = add_sfn(a, b, b[idx].left);
        int right = add_sfn(a, b, b[idx].right);

        a[left].parent = i;
        a[right].parent = i;
        a[i] = node(0, left, right, 0);

        return i;

    } else {
        int i = a.size();
        a.PB(node(b[idx].value, 0, 0, 0));
        return i;
    }
}

sfn add_sfn(const sfn &left, const sfn &right) {
    sfn res;
    res.PB(node(0, 0, 0, 0)); // dummy node
    res.PB(node(0, 0, 0, 0)); // root node

    int l = add_sfn(res, left, 1);
    int r = add_sfn(res, right, 1);
    res[1].left = l;
    res[1].right = r;
    res[l].parent = 1;
    res[r].parent = 1;
    reduce(res);

    return res;
}

ll magnitude(const sfn &s, int idx=1) {
    if (s[idx].left) {
        assert(s[idx].right);
        return 3 * magnitude(s, s[idx].left) + 2 * magnitude(s, s[idx].right);
    } else {
        return s[idx].value;
    }
}

void solve() {
    vector<sfn> nums(100);
    FOR(i, 100) nums[i] = parse();

    ll ans = 0;
    FOR(i, 100) {
        FOR(j, 100) {
            if (i == j) continue;
            ans = max(ans, magnitude(add_sfn(nums[i], nums[j])));
        }
    }
    debug(ans);
}

