/*
    ░░▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒▒▒██▓▓▒▒▒▒████▓▓▒▒▒▒▒▒░░
    ██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒
  ▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒Hele▒Danmarks▒pilsner▒▒▒▒▒▒▒░░░░▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒Ø▒▒▒N▒▒▒▒▒T▒▒U▒▒B▒▒O▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒R▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒R▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒G▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒G▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓██████▒██▒▒▒██▒█████▒▒▒█████▒▒█████▒▒▒█████▒▒▒
██▓▓▒▒██▒▒▒██▒▒▒██▒██▒▒██▒██▒▒▒██▒██▒▒██▒██▒▒▒▒▒▒▒
██▓▓▒▒██▒▒▒██▒▒▒██▒█████▒▒██▒▒▒██▒█████▒▒██▒▒███▒▒
██▓▓▒▒██▒▒▒██▒▒▒██▒██▒▒██▒██▒▒▒██▒██▒▒██▒██▒▒▒██▒▒
██▓▓▒▒██▒▒▒▒█████▒▒█████▒▒▒█████▒▒██▒▒██▒▒█████▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒*▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒*▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒P▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒L▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒I▒▒L▒▒S▒▒N▒▒E▒▒R▒▒▒▒▒▒Ø▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
████▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
████▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██████▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██████████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
  ██████████████████████████████████████████████
      ██████████████████████████████████████
*/

#include<bits/stdc++.h>
using namespace std;
void solve();
template<class F,class S>ostream&operator<<(ostream&o,const pair<F,S>p){return o<<'('<<p.first<<", "<<p.second<<')';}template<class...V>ostream&operator<<(ostream&o,const tuple<V...>t){o<<'(';apply([&o](auto&&...v){((o<<v<<", "),...);},t);o<<"\b\b)";return o;}template<class C,class T=decay<decltype(*begin(declval<C>()))>,typename enable_if<!is_same<C,string>::value>::type* =nullptr>ostream&operator<<(ostream&o,const C&v){o<<'[';for(auto&x:v)o<<x<<", ";if(!v.empty())o<<"\b\b";return o<<']';}
#define debug(x) cerr << #x << " = " << (x) << endl
#define MT(args...) make_tuple(args)
#define PB(a) push_back(a)
#define MP(a, b) make_pair(a, b)
#define FOR(i, n) for(int i = 0; i < (ll)(n); i++)
#define FORS(i,n) for(int i=1;i<=(n);i++)
#define FORE(x,a) for(auto &x: a)
#define FORT(i,a,b) for(int i=(a);i<(b);i++)
#define FORD(i,a,b) for(int i=(a);i>=(b);i--)
#define ALL(x) x.begin(),x.end()
#define F first
#define S second
#define VEC(x,y) typedef vector<x> v##y;typedef vector<v##y> vv##y;typedef vector<vv##y> vvv##y;
#define DEF(x,y) typedef x y;typedef vector<x> v##y;typedef vector<v##y> vv##y;typedef vector<vv##y> vvv##y;
#define COMMA ,
VEC(int,i)VEC(char,c)VEC(string,s)DEF(long long,ll)DEF(long double,ld)DEF(complex<ld>,com)DEF(pair<int COMMA int>,ii)DEF(tuple<int COMMA int COMMA int>,iii)
// #define endl '\n'

const int DX[4] = { 0,  1,  0, -1 };
const int DY[4] = { 1,  0, -1,  0 };
const ll INF = LLONG_MAX / 2 + INT_MAX / 2;

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cout << fixed << setprecision(10);

    int num_cases = 1;
    // cin >> num_cases;
    while (num_cases--) solve();
}

template<class T> struct Point3D {
    typedef Point3D P;
    typedef const P& R;
    T x, y, z;
    explicit Point3D(T x=0, T y=0, T z=0) : x(x), y(y), z(z) {}
    bool operator<(R p) const {
        return tie(x, y, z) < tie(p.x, p.y, p.z); }
    bool operator==(R p) const {
        return tie(x, y, z) == tie(p.x, p.y, p.z); }
    P operator+(R p) const { return P(x+p.x, y+p.y, z+p.z); }
    P operator-(R p) const { return P(x-p.x, y-p.y, z-p.z); }
    P operator*(T d) const { return P(x*d, y*d, z*d); }
    P operator/(T d) const { return P(x/d, y/d, z/d); }
    T dot(R p) const { return x*p.x + y*p.y + z*p.z; }
    P cross(R p) const {
        return P(y*p.z - z*p.y, z*p.x - x*p.z, x*p.y - y*p.x);
    }
    T dist2() const { return x*x + y*y + z*z; }
    double dist() const { return sqrt((double)dist2()); }
    //Azimuthal angle (longitude) to x-axis in interval [-pi, pi]
    double phi() const { return atan2(y, x); } 
    //Zenith angle (latitude) to the z-axis in interval [0, pi]
    double theta() const { return atan2(sqrt(x*x+y*y),z); }
    P unit() const { return *this/(T)dist(); } //makes dist()=1
    //returns unit vector normal to *this and p
    P normal(P p) const { return cross(p).unit(); }
    //returns point rotated 'angle' radians ccw around axis
    P rotate(double angle, P axis) const {
        double s = sin(angle), c = cos(angle); P u = axis.unit();
        return u*dot(u)*(1-c) + (*this)*c - cross(u)*s;
    }
    friend ostream &operator<<(ostream &o, const P &a) {
        return o << '[' << a.x << ", " << a.y << ", " << a.z << ']';
    }
};

using vec3 = Point3D<ll>;

struct mat4 {
    ll M = 4;
    ll N = 4;
    array<ll, 16> data;
    mat4() { data = array<ll, 16>(); }
    mat4(initializer_list<initializer_list<ll>> a) {
        ll i = 0; FORE(l,a) copy(ALL(l), (*this)[i]), i++;
    }
    ll* operator[](ll i) { return &data[i * N]; }
    const ll* operator[](ll i) const { return &data[i * N]; }
    friend ostream &operator<<(ostream &o, const mat4 &a) {
        if (a.M == 0 || a.N == 0) return o << "[[]]";
        o << '[';
        FOR(i, a.M) {
            o << '[';
            FOR(j, a.N) o << a[i][j] << ", ";
            o << "\b\b], ";
        }
        return o << "\b\b]";
    }
    bool operator==(const mat4& a) {
        if (this->M != a.M || this->N != a.N) return false;
        FOR(i, a.M)
            FOR(j, a.N)
                if ((*this)[i][j] != a[i][j]) return false;
        return true;
    }
    bool operator!=(const mat4& a) { return !(*this == a); }

    friend mat4 matmul(const mat4& a, const mat4& b) {
        mat4 res;
        FOR(i, a.M)
            FOR(j, a.N)
                FOR(k, b.N)
                    res[i][k] += a[i][j] * b[j][k];
        return res;
    }
};

mat4 identity = {
    { 1, 0, 0, 0 },
    { 0, 1, 0, 0 },
    { 0, 0, 1, 0 },
    { 0, 0, 0, 1 },
};
mat4 rotate_x = {
    { 1,  0,  0, 0 },
    { 0,  0, -1, 0 },
    { 0,  1,  0, 0 },
    { 0,  0,  0, 1 },
};
mat4 rotate_y = {
    { 0,  0,  1, 0 },
    { 0,  1,  0, 0 },
    {-1,  0,  0, 0 },
    { 0,  0,  0, 1 },
};
mat4 rotate_z = {
    { 0, -1,  0, 0 },
    { 1,  0,  0, 0 },
    { 0,  0,  1, 0 },
    { 0,  0,  0, 1 },
};

vec3 transform_point(mat4 A, vec3 v) {
    ll v4[4] = { v.x, v.y, v.z, 1 };
    ll res[4] = {0, 0, 0, 0};
    FOR(i, 4)
        FOR(j, 4)
            res[i] += A[i][j] * v4[j];
    return vec3(res[0], res[1], res[2]);
}

vector<mat4> find_all_orientations() {
    vector<mat4> res;
    set<array<ll, 16>> visited;
    queue<mat4> q;
    visited.insert(identity.data);
    res.PB(identity);
    q.push(identity);
    while (!q.empty()) {
        mat4 cur = q.front();
        q.pop();
        for (mat4 rot : {rotate_x, rotate_y, rotate_z}) {
            mat4 next = matmul(rot, cur);
            if (visited.find(next.data) == visited.end()) {
                visited.insert(next.data);
                q.push(next);
                res.PB(next);
            }
        }
    }
    return res;
}

ll n;
vector<set<vec3>> scanners;
vector<mat4> orientations;

bool orientation_matches(set<vec3> &s1, set<vec3> &s2, mat4 view) {
    ll cnt = 0;
    FORE(p2, s2) {
        vec3 p_tr = transform_point(view, p2);
        cnt += s1.find(p_tr) != s1.end();
    }
    return cnt >= 12;
}

bool find_orientation(set<vec3> &s1, set<vec3> &s2, mat4 &res) {
    // pick anchor point
    FORE(p1, s1) {
        FORE(p2, s2) {
            // pick orientation
            FORE(ori,  orientations) {
                vec3 p_tr = transform_point(ori, p2);
                vec3 delta = p1 - p_tr;
                mat4 translation = {
                    {1, 0, 0, delta.x},
                    {0, 1, 0, delta.y},
                    {0, 0, 1, delta.z},
                    {0, 0, 0,       1},
                };
                mat4 view = matmul(translation, ori);

                // debug(MT(p1.x,p1.y,p1.z));
                if (orientation_matches(s1, s2, view)) {
                    res = view;
                    return true;
                }
            }
        }
    }
    return false;
}

ll ufds_find(ll x, vi &ufds) {
    return (ufds[x] == x) ? x : (ufds[x] = ufds_find(ufds[x], ufds));
}

void solve() {
    cin >> n;
    scanners = vector<set<vec3>>(n);
    FOR(i, n) {
        ll cnt; cin >> cnt;
        scanners[i] = set<vec3>();
        FOR(j, cnt) {
            ll x, y, z;
            cin >> x >> y >> z;
            scanners[i].insert(vec3(x, y, z));
        }
    }
    debug(scanners);
    orientations = find_all_orientations();

    vi ufds(n);
    FOR(i, n) ufds[i] = i;
    vector<set<vec3>> beacons = scanners;
    vector<set<vec3>> abs_pos(n);
    FOR(i, n) {
        abs_pos[i].insert(vec3(0, 0));
    }

    queue<pair<ll, ll>> remaining;
    for (ll i = 0; i < n; i++) {
        for (ll j = i + 1; j < n; j++) {
            remaining.push(MP(i, j));
        }
    }
    while (!remaining.empty()) {
        ll a, b;
        tie(a, b) = remaining.front();
        remaining.pop();
        ll ra = ufds_find(a, ufds);
        ll rb = ufds_find(b, ufds);
        if (ra == rb) continue;
        if (ra > rb) swap(ra, rb); // try to connect to the component with smaller index
        mat4 res;
        bool found = find_orientation(beacons[ra], beacons[rb], res);
        if (found) {
            debug(MT(ra, rb, res));
            FORE(p, beacons[rb]) {
                beacons[ra].insert(transform_point(res, p));
            }
            FORE(p, abs_pos[rb]) {
                abs_pos[ra].insert(transform_point(res, p));
            }
            ufds[rb] = ra;
            FOR(i, n) {
                remaining.push(MP(ra, i));
            }
        }
    }
    debug(orientations.size());
    debug(ufds);
    debug(beacons[0].size());

    debug(abs_pos[0]);

    ll max_dist = 0;
    FORE(p1, abs_pos[0]) {
        FORE(p2, abs_pos[0]) {
            ll cur_dist = abs(p1.x - p2.x) + abs(p1.y - p2.y) + abs(p1.z - p2.z);
            max_dist = max(cur_dist, max_dist);
        }
    }
    debug(max_dist);
}

