/*
    ░░▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒▒▒██▓▓▒▒▒▒████▓▓▒▒▒▒▒▒░░
    ██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒
  ▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒Hele▒Danmarks▒pilsner▒▒▒▒▒▒▒░░░░▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒Ø▒▒▒N▒▒▒▒▒T▒▒U▒▒B▒▒O▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒R▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒R▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒G▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒G▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓██████▒██▒▒▒██▒█████▒▒▒█████▒▒█████▒▒▒█████▒▒▒
██▓▓▒▒██▒▒▒██▒▒▒██▒██▒▒██▒██▒▒▒██▒██▒▒██▒██▒▒▒▒▒▒▒
██▓▓▒▒██▒▒▒██▒▒▒██▒█████▒▒██▒▒▒██▒█████▒▒██▒▒███▒▒
██▓▓▒▒██▒▒▒██▒▒▒██▒██▒▒██▒██▒▒▒██▒██▒▒██▒██▒▒▒██▒▒
██▓▓▒▒██▒▒▒▒█████▒▒█████▒▒▒█████▒▒██▒▒██▒▒█████▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒*▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒*▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒P▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒L▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒I▒▒L▒▒S▒▒N▒▒E▒▒R▒▒▒▒▒▒Ø▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
████▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
████▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██████▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██████████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
  ██████████████████████████████████████████████
      ██████████████████████████████████████
*/

#include<bits/stdc++.h>
using namespace std;
void solve();
template<class F,class S>ostream&operator<<(ostream&o,const pair<F,S>p){return o<<'('<<p.first<<", "<<p.second<<')';}template<class C,class T=decay<decltype(*begin(declval<C>()))>,typename enable_if<!is_same<C,string>::value>::type* =nullptr>ostream&operator<<(ostream&o,const C&v){o<<'[';for(auto&x:v)o<<x<<", ";if(!v.empty())o<<"\b\b";return o<<']';}template<class T>istream&operator>>(istream&s,vector<T>&v){for(auto&x:v)s>>x;return s;}template<class T>void operator--(vector<T>&v,int){for(auto&x:v)x--;}template<class T>void operator++(vector<T>&v,int){for(auto&x:v)x++;}
#define debug(x) cerr << #x << " = " << (x) << endl
#define MT(args...) make_tuples(args)
#define PB(a) push_back(a)
#define MP(a, b) make_pair(a, b)
#define FOR(i, n) for (int i = 0; i < (ll)(n); i++)
typedef long double ld;
typedef complex<double> com;
typedef vector<com> vc;
typedef long long ll;
typedef vector<int> vi;
typedef vector<vi> vvi;
const int DX[4] = { 0,  1,  0, -1 };
const int DY[4] = { 1,  0, -1,  0 };
const ll INF = LLONG_MAX / 2 + INT_MAX / 2;

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cout << fixed << setprecision(10);

    int num_cases = 1;
    // cin >> num_cases;
    while (num_cases--) solve();
}

const int n = 100;
int hmap[n][n];
int low_cnt[n][n];

int ufds[n * n];
void build_ufds() {
    FOR(i, n * n) ufds[i] = i;
}
int find(int x) {
    return (ufds[x] == x) ? x : (ufds[x] = find(ufds[x]));
}
void connect(int a, int b) {
    if (rand() & 1) swap(a, b);
    ufds[find(a)] = find(b);
}

void dfs(int i, int j) {
    build_ufds();

    low_cnt[i][j]++;
    FOR(k, 4) {
        int ni = i + DY[k];
        int nj = j + DX[k];
        if (ni < 0 || nj < 0 || ni >= n || nj >= n) continue;
        if (hmap[ni][nj] != 9 && hmap[ni][nj] > hmap[i][j]) {
            dfs(ni, nj);
        }
    }
}

void solve() {
    FOR(i, n) {
        string s;
        cin >> s;
        FOR(j, n) {
            hmap[i][j] = s[j] - '0';
        }
    }

    memset(low_cnt, 0, sizeof(low_cnt));
    FOR(i, n) {
        FOR(j, n) {
            int min_neighbor = INF;
            FOR(k, 4) {
                int ni = i + DY[k];
                int nj = j + DX[k];
                if (ni < 0 || nj < 0 || ni >= n || nj >= n) continue;
                min_neighbor = min(min_neighbor, hmap[ni][nj]);
            }
            if (hmap[i][j] < min_neighbor) {
                // lowpoint, run dfs
                dfs(i, j);
            }
        }
    }

    int basin_size[n * n];
    memset(basin_size, 0, sizeof(basin_size));
    FOR(i, n) {
        FOR(j, n) {
            if (low_cnt[i][j] != 1) continue;
            FOR(k, 4) {
                int ni = i + DY[k];
                int nj = j + DX[k];
                if (ni < 0 || nj < 0 || ni >= n || nj >= n) continue;
                if (low_cnt[ni][nj] != 1) continue;
                connect(i * n + j, ni * n + nj);
            }
        }
    }
    FOR(i, n * n) {
        basin_size[find(i)]++;
    }

    priority_queue<int, vi, greater<int>> pq;
    pq.push(0);
    FOR(i, n * n) {
        if (basin_size[i] > pq.top()) {
            pq.push(basin_size[i]);
            if (pq.size() > 3) pq.pop();
        }
    }
    ll ans = 1;
    FOR(i, 3) {
        debug(pq.top());
        ans *= pq.top();
        pq.pop();
    }
    debug(ans);
}

