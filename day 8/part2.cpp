/*
    ░░▒▒▒▒▒▒▓▓▒▒▒▒▒▒▒▒▒▒██▓▓▒▒▒▒████▓▓▒▒▒▒▒▒░░
    ██░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒
  ▒▒▒▒▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒Hele▒Danmarks▒pilsner▒▒▒▒▒▒▒░░░░▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒Ø▒▒▒N▒▒▒▒▒T▒▒U▒▒B▒▒O▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒R▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒R▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒G▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒G▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓██████▒██▒▒▒██▒█████▒▒▒█████▒▒█████▒▒▒█████▒▒▒
██▓▓▒▒██▒▒▒██▒▒▒██▒██▒▒██▒██▒▒▒██▒██▒▒██▒██▒▒▒▒▒▒▒
██▓▓▒▒██▒▒▒██▒▒▒██▒█████▒▒██▒▒▒██▒█████▒▒██▒▒███▒▒
██▓▓▒▒██▒▒▒██▒▒▒██▒██▒▒██▒██▒▒▒██▒██▒▒██▒██▒▒▒██▒▒
██▓▓▒▒██▒▒▒▒█████▒▒█████▒▒▒█████▒▒██▒▒██▒▒█████▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒*▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒*▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒P▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒L▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒I▒▒L▒▒S▒▒N▒▒E▒▒R▒▒▒▒▒▒Ø▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
████▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
████▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██████▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
██████████▓▓▓▓▓▓▓▓▓▓▓▓▓▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
  ██████████████████████████████████████████████
      ██████████████████████████████████████
*/

#include<bits/stdc++.h>
using namespace std;
void solve();
template<class F,class S>ostream&operator<<(ostream&o,const pair<F,S>p){return o<<'('<<p.first<<", "<<p.second<<')';}template<class...V>ostream&operator<<(ostream&o,const tuple<V...>t){o<<'(';apply([&o](auto&&...v){((o<<v<<", "),...);},t);o<<"\b\b)";return o;}template<class C,class T=decay<decltype(*begin(declval<C>()))>,typename enable_if<!is_same<C,string>::value>::type* =nullptr>ostream&operator<<(ostream&o,const C&v){o<<'[';for(auto&x:v)o<<x<<", ";if(!v.empty())o<<"\b\b";return o<<']';}
#define debug(x) cerr << #x << " = " << (x) << endl
#define MT(args...) make_tuple(args)
#define PB(a) push_back(a)
#define MP(a, b) make_pair(a, b)
#define FOR(i, n) for(int i = 0; i < (ll)(n); i++)
#define FORS(i,n) for(int i=1;i<=(n);i++)
#define FORE(x,a) for(auto &x: a)
#define FORT(i,a,b) for(int i=(a);i<(b);i++)
#define FORD(i,a,b) for(int i=(a);i>=(b);i--)
#define ALL(x) x.begin(),x.end()
#define F first
#define S second
#define VEC(x,y) typedef vector<x> v##y;typedef vector<v##y> vv##y;typedef vector<vv##y> vvv##y;
#define DEF(x,y) typedef x y;typedef vector<x> v##y;typedef vector<v##y> vv##y;typedef vector<vv##y> vvv##y;
#define COMMA ,
VEC(int,i)VEC(char,c)VEC(string,s)DEF(long long,ll)DEF(long double,ld)DEF(complex<ld>,com)DEF(pair<int COMMA int>,ii)DEF(tuple<int COMMA int COMMA int>,iii)
// #define endl '\n'

const int DX[4] = { 0,  1,  0, -1 };
const int DY[4] = { 1,  0, -1,  0 };
const ll INF = LLONG_MAX / 2 + INT_MAX / 2;

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cout << fixed << setprecision(10);

    int num_cases = 1;
    // cin >> num_cases;
    while (num_cases--) solve();
}

int bitcnt(int x) {
    return __builtin_popcount(x);
}

void solve() {
    vector<vector<string>> input(200);
    vector<vector<string>> output(200);

    FOR(i, 200) {
        input[i] = vector<string>(10);
        output[i] = vector<string>(4);
        FOR(j, 10) {
            cin >> input[i][j];
        }
        sort(ALL(input[i]), [](const string &a, const string &b) -> bool {
            return a.size() < b.size();
        });
        cin.ignore(3);
        FOR(j, 4) {
            cin >> output[i][j];
        }
    }

    // debug(input[0]);

    vvi segs(200);
    vvi segs_out(200);
    FOR(i, 200) {
        segs[i] = vi(10);
        segs_out[i] = vi(4);
        FOR(j, 10) {
            FORE(c, input[i][j]) {
                segs[i][j] |= 1 << (c - 'a');
            }
        }
        FOR(j, 4) {
            FORE(c, output[i][j]) {
                segs_out[i][j] |= 1 << (c - 'a');
            }
        }
    }

    ll sum = 0;
    FOR(i, 200) {
        vi mapsto(10);
        mapsto[0] = 1;
        mapsto[1] = 7;
        mapsto[2] = 4;
        mapsto[9] = 8;

        int bd = segs[i][2] ^ segs[i][0]; // 4 \ 1

        // 5 segments (2, 3, 5)
        for (int j = 3; j <= 5; j++) {
            if ((segs[i][j] & segs[i][0]) == segs[i][0]) {
                mapsto[j] = 3;
            } else if ((segs[i][j] & bd) == bd) {
                mapsto[j] = 5;
            } else {
                mapsto[j] = 2;
            }
        }

        // 6 segments (0, 6, 9)
        for (int j = 6; j <= 8; j++) {
            if ((segs[i][j] & segs[i][0]) != segs[i][0]) {
                mapsto[j] = 6;
            } else if ((segs[i][j] & bd) == bd) {
                mapsto[j] = 9;
            } else {
                mapsto[j] = 0;
            }
        }

        ll cur_value = 0;
        FOR(j, 4) {
            int idx = 0;
            for(; idx < 10; idx++) {
                if (segs_out[i][j] == segs[i][idx]) break;
            }
            cur_value = 10 * cur_value + mapsto[idx];
        }
        sum += cur_value;
        debug(mapsto);
        debug(cur_value);
    }
    debug(sum);
}

